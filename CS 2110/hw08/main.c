#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */
// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"
#include "images/starry_night.h"
#include "images/vangoghsp.h"
#include "images/sunflowers.h"
#include "images/irises.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};

void start(enum gba_state *state, struct game *g, u32 currentButtons, u32 previousButtons);
void play(enum gba_state *state, struct game *g, u32 currentButtons, u32 previousButtons);
void player_controls(struct player *p, u32 currentButtons, u32 previousButtons);
void respawn(struct player *p);
void reset(struct game *g);
void win(enum gba_state *state, u32 currentButtons, u32 previousButtons);
void lose(enum gba_state *state, u32 currentButtons, u32 previousButtons);
void winTransition(void);
void loseTransition(void);
void startTransition(void);

void start(enum gba_state *state, struct game *g, u32 currentButtons, u32 previousButtons) {
  if (KEY_JUST_PRESSED(BUTTON_START, currentButtons, previousButtons)) {
    *state = PLAY;
    // drawFullScreenImageDMA(starry_night);
    vBlankCounter = 0;
    
    fillScreenDMA(BLACK);
    reset(g);
  }
}

void play(enum gba_state *state, struct game *g, u32 currentButtons, u32 previousButtons) {
  UNUSED(currentButtons);
  UNUSED(previousButtons);
  UNUSED(state);

  if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
    *state = START;
    startTransition();
    return;
  }

  player_controls(&(g->p), currentButtons, previousButtons);
  waitForVBlank();
  undrawImageDMA(g->p.prev_row, g->p.prev_col, g->p.sidelen, g->p.sidelen, starry_night);
  drawImageSectionDMA(g->p.row, g->p.col, g->g.row, g->g.col, g->g.sidelen, g->g.sidelen, starry_night);
  // drawRectDMA(50, 150, 30, 30, RED);
  drawImageDMA(50, 150, 30, 30, sunflowers);
  // drawRectDMA(0, 0, 10, vBlankCounter/20, GREEN);

  int asc = 57 - vBlankCounter / 300;
  char str[] = {asc, 0};

  undrawImageDMA(10, 10, 80, 30, starry_night);
  drawCenteredString(10, 10, 80, 30, str, WHITE);

  if (asc == 48) {
  
      loseTransition();
      lose(state, currentButtons, previousButtons);
      *state = LOSE;
  }

  if (g->p.row + g->p.sidelen > 50 && g->p.row < 80
      && g->p.col + g->p.sidelen > 150 && g->p.col < 180) {
      loseTransition();
      lose(state, currentButtons, previousButtons);
      *state = LOSE;
  }

  // drawCenteredString(10, WIDTH/2, 80, 30, str, RED);
  // undrawImageDMA(10, WIDTH/2, 80, 30, starry_night);

  win(state, currentButtons, previousButtons);
  if (g->p.row == g->g.row && g->p.col == g->g.col) {
    winTransition();
    win(state, currentButtons, previousButtons);
    *state = WIN;
  }
}

void player_controls(struct player *p, u32 currentButtons, u32 previousButtons) {
  p->prev_row = p->row;
  p->prev_col = p->col;

  if (KEY_DOWN(BUTTON_A, currentButtons)) {
    if (KEY_JUST_PRESSED(BUTTON_RIGHT, currentButtons, previousButtons)) {
      p->col += 1;
    }
    if (KEY_JUST_PRESSED(BUTTON_LEFT, currentButtons, previousButtons)) {
      p->col -= 1;
    }
    if (KEY_JUST_PRESSED(BUTTON_DOWN, currentButtons, previousButtons)) {
      p->row += 1;
    }
    if (KEY_JUST_PRESSED(BUTTON_UP, currentButtons, previousButtons)) {
      p->row -= 1;
    }

    return;
  }

  if (KEY_DOWN(BUTTON_RIGHT, currentButtons)) {
    p->col += 1;
  }
  if (KEY_DOWN(BUTTON_LEFT, currentButtons)) {
    p->col -= 1;
  }
  if (KEY_DOWN(BUTTON_DOWN, currentButtons)) {
    p->row += 1;
  }
  if (KEY_DOWN(BUTTON_UP, currentButtons)) {
    p->row -= 1;
  }
}

void respawn(struct player *p) {
  p->row = 50;
  p->col = 50;
  p->prev_row = 50;
  p->prev_col = 50;
  p->spawn_row = 50;
  p->spawn_col = 50;
  p->sidelen = 25;
}

void reset(struct game *g) {
  respawn(&(g->p));
  g->g.row = 80;
  g->g.col = 40;
  g->g.sidelen = 25;
}

void win(enum gba_state *state, u32 currentButtons, u32 previousButtons) {
  if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
    *state = START;
    startTransition();
    return;
  }
}

void lose(enum gba_state *state, u32 currentButtons, u32 previousButtons) {
  if (KEY_JUST_PRESSED(BUTTON_SELECT, currentButtons, previousButtons)) {
    *state = START;
    startTransition();
    return;
  }
}

void winTransition(void) {
  waitForVBlank();
  // fillScreenDMA(GREEN);
  drawFullScreenImageDMA(irises);
  char *str = "YOU WIN";
  drawCenteredString(10, WIDTH/2, 80, 30, str, WHITE);
}

void loseTransition(void) {
  waitForVBlank();
  fillScreenDMA(RED);
  char *str = "YOU LOSE";
  drawCenteredString(10, WIDTH/2, 80, 30, str, BLACK);
}

void startTransition(void) {
  waitForVBlank();
  // fillScreenDMA(BLUE);
  drawFullScreenImageDMA(starry_night);
  drawImageDMA(HEIGHT / 2 - 35, WIDTH / 2 - 25, 50, 70, vgsp);
  char *str = "FIND WHERE IT BELONGS";
  drawCenteredString(10, WIDTH/2, 80, 30, str, RED);
}

int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //
  REG_DISPCNT = MODE3 | BG2_ENABLE;
  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;
  struct player p;
  struct goal g;
  struct game game;
  
  
  p.row = 50;
  p.col = 50;
  p.prev_row = 50;
  p.prev_col = 50;
  p.spawn_row = 50;
  p.spawn_col = 50;
  p.sidelen = 25;
  g.row = 80;
  g.col = 80;
  g.sidelen = 25;
  
  game.p = p;
  game.g = g;

  // initial start state
  startTransition();

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:
        start(&state, &game, currentButtons, previousButtons);
        printf("here\n");
        // state = ?
        break;
      case PLAY:
        play(&state, &game, currentButtons, previousButtons);
        // fillScreenDMA(RED);
        // state = ?
        break;
      case WIN:
        win(&state, currentButtons, previousButtons);
        // state = ?
        break;
      case LOSE:
        lose(&state, currentButtons, previousButtons);
        // state = ?
        break;
    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  UNUSED(previousButtons); // You can remove this once previousButtons is used

  return 0;
}
